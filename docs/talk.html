<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Introducción a SOLID, Unit Test &amp; Clean Architecture</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="reveal.js/css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="style/ude.css" id="theme"><!--This CSS is generated by the Asciidoctor-Reveal.js converter to further integrate AsciiDoc's existing semantic with Reveal.js--><style type="text/css">.reveal div.right {
  float: right;
}

/* callouts */
.conum[data-value] {display:inline-block;color:#fff!important;background-color:rgba(50,150,50,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}</style><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css"><link href="css/github.css" rel="stylesheet"><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "reveal.js/css/print/pdf.css" : "reveal.js/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="reveal.js/lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><script type="text/javascript">
    window.addEventListener("load", function() {

        revealDiv = document.querySelector("body div.reveal")
        footer = document.getElementById("schauderhaft-footer");
        revealDiv.appendChild(footer);

    } );
</script>
<div id="schauderhaft-footer" class="footer">
    <span class="element"></span>
    <span class="element"></span>
    <span class="element">Intro SOLID/Test/Clean</span>
</div>
<section id="_introducción_a_solid_unit_test_clean_architecture"><h2>Introducción a SOLID, Unit Test &amp; Clean Architecture</h2></section>
<section id="_principios_solid"><h2>Principios SOLID</h2><div class="ulist"><ul><li><p>Single responsibility <span class="icon"><i class="fa fa-cube"></i></span></p></li><li><p>Open closed <span class="icon"><i class="fa fa-unlock"></i></span>/<span class="icon"><i class="fa fa-lock"></i></span></p></li><li><p>Liskov substitution <span class="icon"><i class="fa fa-users"></i></span></p></li><li><p>Interface segregation <span class="icon"><i class="fa fa-cut"></i></span></p></li><li><p>Dependency inversion <span class="icon"><i class="fa fa-cubes"></i></span></p></li></ul></div></section>
<section id="_principio_de_responsabilidad_única"><h2>Principio de Responsabilidad Única <span class="icon"><i class="fa fa-cube"></i></span></h2><div class="paragraph"><p><strong>Un objeto debe realizar una única cosa</strong>.</p></div>
<div class="paragraph"><p><strong>Un objeto debe tener una sola razón para cambiar.</strong></p></div>
<aside class="notes"><div class="paragraph"><p>Es muy habitual, si no prestamos atención a esto, que acabemos
teniendo clases que tienen varias responsabilidades lógicas a la vez.</p></div></aside></section>
<section id="_cómo_detectar_si_estamos_violando_el_principio_de_responsabilidad_única"><h2>¿Cómo detectar si estamos violando el Principio de Responsabilidad Única?</h2></section>
<section><div class="ulist"><ul><li><p>En una misma clase están involucradas dos capas de la arquitectura</p></li><li><p>El número de métodos públicos</p></li><li><p>Los métodos que usan cada uno de los campos de esa clase</p></li><li><p>Por el número de imports</p></li></ul></div></section>
<section><div class="ulist"><ul><li><p>Nos cuesta testear la clase</p></li><li><p>Cada vez que escribes una nueva funcionalidad, esa clase se ve afectada</p></li><li><p>Por el número de líneas</p></li></ul></div></section>
<section id="_ejemplo"><h2>Ejemplo</h2><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">class Vehicle {
  private val wheelCount = 4
  private val maxSpeed = 200
  override fun toString():String {
    return "wheelCount=$wheelCount, maxSpeed=$maxSpeed"
  }
  fun print() {
    println(toString())
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>Esta es una clase sencilla con datos y lógica de negocio.</p></div></aside></section>
<section id="_qué_problema_tiene_esta_clase"><h2>¿Qué problema tiene esta clase?</h2></section>
<section><div class="ulist"><ul><li><p>Mezcla de lógica con presentación</p></li></ul></div></section>
<section id="_cómo_arreglarlo"><h2>¿Cómo arreglarlo?</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">class VehiclePrinter {
  fun print(vehicle:Vehicle) {
    println(vehicle)
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>En este caso implementando un printer dedicado.</p></div></aside></section>
<section id="_principio_openclosed"><h2>Principio Open/Closed <span class="icon"><i class="fa fa-unlock"></i></span>/<span class="icon"><i class="fa fa-lock"></i></span></h2><div class="paragraph"><p><strong>Una entidad de software debería estar abierta a extensión pero cerrada a modificación</strong>.</p></div></section>
<section id="_cómo_detectar_que_estamos_violando_el_principio_openclosed"><h2>¿Cómo detectar que estamos violando el principio Open/Closed?</h2></section>
<section><div class="ulist"><ul><li><p>Clases que modificamos más seguido (hits of code)</p></li></ul></div></section>
<section id="_ejemplo_2"><h2>Ejemplo</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">class Vehicle {
  //…
  val type:VehicleType
  //…
}
enum class VehicleType {
  CAR,
  MOTORBIKE;
}
fun draw(vehicle:Vehicle) {
    when (vehicle.type) {
      CAR -&gt; drawCar(vehicle)
      MOTORBIKE -&gt; drawMotorbike(vehicle)
    }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>Siguiendo con el ejemplo del vehículo anterior, ahora con funcionalidad de dibujar <code>draw</code>. Al principio es sencilla la implementación y puede ser suficiente para la aplicación, pero se presenta que cada vez que se quiera dibujar un nuevo vehículo se debe actualizar el contenido del método, el enum y la lógica en la propia que clase que nos interesaría dibujar.</p></div></aside></section>
<section id="_qué_podemos_hacer_para_evitar_tener_que_estar_modificando_el_método_draw"><h2>¿Qué podemos hacer para evitar tener que estar modificando el método <code>draw</code>?</h2></section>
<section id="_polimorfismo"><h2>Polimorfismo</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">abstract class Vehicle {
  //…
  abstract fun draw()
}
class Car:Vehicle() {
  override fun draw() {
    // Draw the car
  }
}
class Motorbike:Vehicle() {
  override fun draw() {
    // Draw the motorbike
  }
}</code></pre></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">fun draw(vehicle:Vehicle) {
  vehicle.draw()
}
class Truck:Vehicle() {
  override fun draw() {
    // Draw the truck
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>Al utilizar polimorfismo en este caso cada objeto que deseemos dibujar lo único que necesita es implementar la interfaz. Adicionalmente se simplifica el método draw original, pues en runtime invocará la implementación correspondiente, por lo que ya no necesitamos el enum para este caso.</p></div></aside></section>
<section id="_cuándo_debemos_cumplir_con_este_principio"><h2>¿Cuándo debemos cumplir con este principio?</h2><div class="ulist"><ul><li><p>Depende, debe aplicarse cuando es necesario. La complejidad no siempre compensa.</p></li><li><p>Un caso práctico es cuando hay partes de nuestro código que cambien mucho.</p></li></ul></div></section>
<section id="_principio_de_sustitución_de_liskov"><h2>Principio de Sustitución de Liskov <span class="icon"><i class="fa fa-users"></i></span></h2><div class="paragraph"><p><strong>Si en alguna parte de nuestro código estamos usando una clase, y esta clase es extendida, tenemos que poder utilizar cualquiera de las clases hijas y que el programa siga siendo válido.</strong></p></div></section>
<section id="_cómo_detectar_que_estamos_violando_el_principio_de_sustitución_de_liskov"><h2>¿Cómo detectar que estamos violando el principio de sustitución de Liskov?</h2><div class="ulist"><ul><li><p>Si un método sobrescrito no hace nada o lanza una excepción.</p></li></ul></div></section>
<section id="_ejemplo_3"><h2>Ejemplo</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">open class Rectangle {
  open var width:Int = 0
  open var height:Int = 0
  open fun calculateArea():Int {
    return width * height
  }
}
@Test
fun givenRectangle_whenCalculateArea_thenCorrectResult() {
  val r = Rectangle()
  r.width = 5
  r.height = 4

  val result = r.calculateArea()

  assertEquals(20, result)
}</code></pre>
<aside class="notes"><div class="paragraph"><p>En este caso tenemos un rectángulo común y un test para probar el cálculo del área.</p></div></aside></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">class Square:Rectangle() {
  override var width:Int
  get() {
    return super.width
  }
  set(width) {
    super.width = width
    super.height = width
  }
  override var height:Int
  get() {
    return super.height
  }
  set(height) {
    super.height = height
    super.width = height
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>La pudiéramos extender para soportar por ejemplo un cuadrado.</p></div></aside></section>
<section id="_qué_pasará_si_en_el_test_cambiamos_el_rectángulo_por_un_cuadrado"><h2>¿Qué pasará si en el test cambiamos el rectángulo por un cuadrado?</h2></section>
<section id="_1620"><h2>16!=20</h2><aside class="notes"><div class="paragraph"><p>El test falla porque cada vez que cambiamos un lado afectamos el otro.</p></div></aside></section>
<section id="_qué_podemos_hacer"><h2>¿Qué podemos hacer?</h2><div class="ulist"><ul><li><p>Usar interfaces, normalmente pequeñas.</p></li><li><p>Inmutabilidad (Una vez que se ha creado un objeto, el estado del mismo no puede volver a modificarse)</p></li></ul></div></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">interface IRectangle {
  fun calculateArea():Int
}
class Rectangle:IRectangle//…
class Square:IRectangle//…</code></pre></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">open class Rectangle(private val width:Int, private val height:Int)
class Square(private val side:Int):Rectangle(side, side)</code></pre></section>
<section id="_principio_de_segregación_de_interfaces"><h2>Principio de segregación de interfaces <span class="icon"><i class="fa fa-cut"></i></span></h2><div class="paragraph"><p><strong>Ninguna clase debería depender de métodos que no usa.</strong></p></div></section>
<section id="_cómo_detectar_que_estamos_violando_el_principio_de_segregación_de_interfaces"><h2>¿Cómo detectar que estamos violando el Principio de segregación de interfaces?</h2><div class="ulist"><ul><li><p>Al implementar una interfaz ves que uno o varios de los métodos no tienen sentido y te hace falta dejarlos vacíos o
lanzar excepciones</p></li></ul></div></section>
<section id="_ejemplo_4"><h2>Ejemplo</h2><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">interface Product {
  fun name():String
  fun stock():Int
  fun numberOfDisks():Int
  fun releaseDate():Date
}
class CD:Product//…</code></pre>
<aside class="notes"><div class="paragraph"><p>Imaginemos que una tienda que vende CD musicales el sistema de datos esta modelado con esa interfaz.</p></div></aside></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">interface Product {
  //…
  fun recommendedAge():Int
}
class CD:Product {
  //…
  override fun recommendedAge():Int {
    throw UnsupportedOperationException()
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>Pero si ahora deseamos vender DVD y queremos limitar la edad por ejemplo.</p></div></aside></section>
<section id="_qué_podemos_hacer_2"><h2>¿Qué podemos hacer?</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">interface AgeAware {
  fun recommendedAge():Int
}
class CD:Product//…
class DVD:Product, AgeAware {
  fun checkUserCanBuy(user:User, ageAware:AgeAware):Boolean {
    return user.age &gt;= ageAware.recommendedAge()
  }
  //…
}</code></pre>
<aside class="notes"><div class="paragraph"><p>En este caso ahora tenemos una interfaz más chica <code>AgeAware</code>, con responsabilidades acotadas y no afecta a la clase <code>CD</code>.</p></div></aside></section>
<section id="_qué_hacer_con_código_antiguo"><h2>¿Qué hacer con código antiguo?</h2><div class="ulist"><ul><li><p>Usar el patrón adapter</p></li></ul></div></section>
<section id="_principio_de_inversión_de_dependencias"><h2>Principio de inversión de dependencias <span class="icon"><i class="fa fa-cubes"></i></span></h2><div class="ulist"><ul><li><p><strong>Las clases de alto nivel no deberían depender de las clases de bajo nivel</strong>. Ambas deberían depender de las abstracciones.</p></li><li><p><strong>Las abstracciones no deberían depender de los detalles</strong>. Los detalles deberían depender de las abstracciones.</p></li></ul></div></section>
<section id="_cómo_detectar_que_estamos_violando_el_principio_de_inversión_de_dependencias"><h2>¿Cómo detectar que estamos violando el Principio de inversión de dependencias?</h2><div class="ulist"><ul><li><p>Cualquier instanciación de clases complejas o módulos es una
violación de este principio.</p></li></ul></div></section>
<section id="_ejemplo_5"><h2>Ejemplo</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">class ShoppingBasket {
  fun buy(shopping:Shopping) {
    val db = SqlDatabase()
    db.save(shopping)
    val creditCard = CreditCard()
    creditCard.pay(shopping)
  }
}
class SqlDatabase {
  fun save(shopping:Shopping) {
    // Saves data in SQL database
  }
}
class CreditCard {
  fun pay(shopping:Shopping) {
    // Performs payment using a credit card
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>En este ejemplo tenemos la clase <code>ShoppingBasket</code> que persiste y envía el pago por tarjeta de crédito. El problema que tiene es que primero depende de clases concretas en vez de abstracciones y segundo estás dependencias son creadas dentro de la propia clase.</p></div></aside></section>
<section id="_cómo_lo_solucionamos"><h2>¿Cómo lo solucionamos?</h2><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">interface Persistence {
  fun save(shopping:Shopping)
}
class SqlDatabase:Persistence {
  override fun save(shopping:Shopping) {
    // Saves data in SQL database
  }
}
interface PaymentMethod {
  fun pay(shopping:Shopping)
}
class CreditCard:PaymentMethod {
  override fun pay(shopping:Shopping) {
    // Performs payment using a credit card
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>Una manera de arreglarlo es crear interfaces dedicadas para las dependencias.</p></div></aside></section>
<section id="_ahora_inyectamos_las_dependencias"><h2>Ahora inyectamos las dependencias</h2></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">class ShoppingBasket(private val persistence:Persistence, private val paymentMethod:PaymentMethod) {
  fun buy(shopping:Shopping) {
    persistence.save(shopping)
    paymentMethod.pay(shopping)
  }
}
class Server:Persistence {
  override fun save(shopping:Shopping) {
    // Saves data in a server
  }
}
class Paypal:PaymentMethod {
  override fun pay(shopping:Shopping) {
    // Performs payment using Paypal account
  }
}</code></pre>
<aside class="notes"><div class="paragraph"><p>Y ahora les pasamos las dependencias al constructor de la clase, esto nos da la flexibilidad de cambiar la implementación sin necesidad de actualizar la clase. Otra ventaja es que al tener las dependencias en el constructor se nos da una vista previa de las responsabilidades que esta clase maneja, pudiendo detectar rápidamente en caso que empiece a crecer la violación del principio de responsabilidad única.</p></div></aside></section>
<section id="_testing"><h2>Testing <span class="icon"><i class="fa fa-shield"></i></span></h2></section>
<section id="_por_qué_escribimos_tests"><h2>¿Por qué escribimos tests? <span class="icon"><i class="fa fa-lightbulb"></i></span></h2></section>
<section id="_por_qué_escribimos_tests_2"><h2>¿Por qué escribimos tests?</h2><div class="ulist"><ul><li><p>Para asegurarnos que el código funciona</p></li><li><p>&#8230;&#8203; pero escribir test automatizados es mucho más trabajo que simplemente escribir el <code>main</code> y validar entradas y salidas &#8230;&#8203;</p></li></ul></div></section>
<section id="_el_software_cambia"><h2>El software cambia <span class="icon"><i class="fa fa-code"></i></span></h2><div class="ulist"><ul><li><p>Si el software cambia, los test deben cambiar con él</p></li><li><p>Si cambiamos la estructura de nuestras clases, tenemos que adaptar los test, perder tiempo</p></li><li><p>Si añadimos nuevas funcionalidades obviamente no vamos a tener tests</p></li><li><p>Si arreglamos <span class="icon"><i class="fa fa-bug"></i></span>, al principio no vamos a tener test</p></li></ul></div></section>
<section id="_refactoring"><h2>Refactoring <span class="icon"><i class="fa fa-magic"></i></span></h2><div class="paragraph"><p>No todos los cambios son funcionales</p></div>
<div class="paragraph"><p><strong>Refactor</strong>&#8201;&#8212;&#8201;Proceso de de reestructurar un código fuente, alterando su estructura interna sin cambiar su comportamiento externo.</p></div></section>
<section id="_razones_para_hacer_refactoring"><h2>Razones para hacer refactoring <span class="icon"><i class="fa fa-magic"></i></span></h2><div class="ulist"><ul><li><p>Reparar <span class="icon"><i class="fa fa-bug"></i></span> en el código (code smells)</p></li><li><p>Pagar deuda técnica</p></li><li><p>Mejorar rendimiento</p></li><li><p>Actualizar API</p></li><li><p>&#8230;&#8203;</p></li></ul></div></section>
<section data-background-image="./images/refactor-catalog.PNG" data-background-size="auto"></section>
<section id="_estrategias_para_hacer_refactoring"><h2>Estrategias para hacer refactoring <span class="icon"><i class="fa fa-magic"></i></span></h2><div class="olist arabic"><ol class="arabic"><li><p>Preparar el código para la nueva funcionalidad</p></li><li><p>Añadir la nueva funcionalidad</p></li></ol></div></section>
<section id="_cuándo_hacer_refactoring"><h2>¿Cuándo hacer refactoring <span class="icon"><i class="fa fa-magic"></i></span>?</h2><div class="olist arabic"><ol class="arabic"><li><p>Debería ser algo de todos los días</p></li><li><p>Los IDEs ayudan a automatizar de manera segura refactors simples</p></li></ol></div></section>
<section id="_regla_del_boyscout" data-background-image="./images/boy-scout-rule.jpeg" data-background-size="auto"><h2>Regla del Boyscout</h2></section>
<section id="_refactors_inseguros"><h2>Refactors inseguros <span class="icon"><i class="fa fa-exclamation-triangle"></i></span></h2><div class="paragraph"><p>No todos los refactors son seguros:</p></div>
<div class="ulist"><ul><li><p>Inlining (efectos secundarios)</p></li><li><p>Cambiar dependencias</p></li><li><p>Cambiar algoritmos o estructuras de datos</p></li><li><p>&#8230;&#8203; Cualquier cambio no trivial</p></li></ul></div></section>
<section id="_refactors_seguros"><h2>Refactors seguros <span class="icon"><i class="fa fa-check"></i></span></h2><div class="paragraph"><p>Para hacer refactor seguros, <strong>tenemos que escribir tests</strong></p></div>
<div class="paragraph"><p>No escribimos tests para asegurarnos que el código funcione</p></div>
<div class="paragraph"><p><strong>Escribimos test para asegurarnos que siga funcionando</strong></p></div></section>
<section id="_usar_tests"><h2>Usar tests <span class="icon"><i class="fa fa-check"></i></span></h2><div class="paragraph"><p>Si no se escriben test se crea <strong>código legacy</strong>.</p></div>
<div class="imageblock" style=""><img src="./images/legacy-code-sequence.PNG" alt="legacy code sequence"></div>
<div class="paragraph"><p>Es una relación <strong>cíclica</strong>.</p></div></section>
<section id="_ciclo_de_refactor_malo" data-background-image="./images/bad-refactoring-cycle.PNG" data-background-size="auto"><h2>Ciclo de refactor malo</h2></section>
<section id="_ciclo_de_refactor_bueno" data-background-image="./images/good-refactoring-cycle.PNG" data-background-size="auto"><h2>Ciclo de refactor bueno</h2></section>
<section id="_otras_razones_para_hacer_test"><h2>Otras razones para hacer test</h2><div class="ulist"><ul><li><p>Es una prueba de que el código funciona.</p></li><li><p>Son una fuente de documentación, muestran las intenciones del código.</p></li><li><p>Mejoran el diseño de la aplicación.</p></li></ul></div></section>
<section id="_niveles_de_test"><h2>Niveles de test</h2><div class="ulist"><ul><li><p>Unit tests</p></li><li><p>Integration tests</p></li><li><p>End to End tests</p></li><li><p>Acceptance / Business logic tests</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Unit tests: Prueban una sola unidad del sistema. No tienen dependencias de los componentes externos del sistema BD, WS, API. Falsifican sus dependencias.</p></li><li><p>Integration tests: Verifica que grupos de unidades puedan trabajar juntas correctamente.</p></li><li><p>End-to-End tests: Prueba flujos completos de interacciones en el sistema. Se puede considerar como extensión de los test de integración. Tiene dependencias reales a los componentes del sistema, BD, WS, APIs.</p></li><li><p>Acceptance / Business logic tests: Buscan responder la pregunta, ¿construimos lo que el cliente esperaba? Normalmente se centra en la historia del usuario y usan el lenguaje del negocio.</p></li></ul></div></aside></section>
<section id="_qué_porcentaje_debo_cubrir"><h2>¿Qué porcentaje debo cubrir?</h2><div class="ulist"><ul><li><p>70% Unit tests</p></li><li><p>20% Integration</p></li><li><p>10%  End to End tests</p></li></ul></div></section>
<section id="_pirámide_de_testing" data-background-image="./images/pyramid.png" data-background-size="auto"><h2>Pirámide de testing</h2></section>
<section id="_qué_es_una_unidad"><h2>¿Qué es una unidad?</h2><div class="ulist"><ul><li><p>Una clase (la mayoría de las veces)</p></li><li><p>Muchas clases relacionadas</p></li><li><p>Un paquete. Usualmente solo se prueba el API público, la interna y privada se prueba de manera implícita.</p></li></ul></div></section>
<section id="_requisitos_de_un_test"><h2>Requisitos de un test</h2><div class="ulist"><ul><li><p>Rápido</p></li><li><p>Coherente</p></li><li><p>Modular</p></li><li><p>Independiente de la implementación</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Rápido: Los tests unitarios deben ejecutarse rápidamente. Entre más pronto y frecuente se ejecuten, más temprano se van a detectar las fallas y corregirse.
Los tiempos de ejecución deben estar en el orden de los milisegundos. No deben tener acceso I/O y sus entradas deben ser las mínimas necesarias.</p></li><li><p>Coherente: Leer test deben poderse leer de manera fácil. La idea es que revelen las intenciones del código de producción.
Pueden ser usados como documentación. Deben estar escritos de manera estructurada y consistente.</p></li><li><p>Modular: Unidad debe ser lo más pequeña posible. El objetivo es buscar que los test sean lo más pequeño posible también.
Se prefiere escribir muchos pequeños test que grandes tests. En lo posible buscar tener un solo asssert por test (Pueden ser múltiples cuando se validan datos).
 Los test usualmente no deberían fallar por un problema en las dependencias.</p></li><li><p>Independiente de la implementación: Los test deben validar la salida con respecto a una entrada.
Normalmente no se debe cambiar un test si la implementación cambia, solo se hace si cambia la funcionalidad externa.
  Se debe evitar escribir test que simplemente repitan el código de producción. El objetivo de los test es facilitar el refactor.
  Preferir en lo posible test de caja negra que de caja blanca.</p><div class="ulist"><ul><li><p>Caja negra: Se prueba la funcionalidad sin conocer su implementación.</p></li><li><p>Caja blanca: Se prueba conociendo los detalles de la implementación.</p></li></ul></div></li></ul></div></aside></section>
<section id="_estructura_de_un_test"><h2>Estructura de un test</h2><div class="olist arabic"><ol class="arabic"><li><p>Arrange (Planificación)</p></li><li><p>Act (Acción)</p></li><li><p>Assert (Afirmación)</p></li></ol></div></section>
<section><pre class="highlight listingblock"><code data-noescape class="kotlin language-kotlin">@Test
fun givenString_whenReverse_thenGetReverseString() {
  val input = "abc" <i class="conum" data-value="1"></i><b>(1)</b>

  val result = StringUtils.reverse(input) <i class="conum" data-value="2"></i><b>(2)</b>

  assertThat(result).isEqualTo("cba") <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre></section>
<section id="_buenas_prácticas_12"><h2>Buenas Prácticas 1/2</h2><div class="ulist"><ul><li><p>Evitar repetir código de producción.</p></li><li><p>Se debe evitar escribir lógica en los test.</p></li><li><p>Agregar al menos un test cuando se soluciona una falla.</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>El código de producción describe una solución general.</p></li><li><p>El código del test es concreto.</p></li><li><p>Se recomienda especificar entradas y salidas concretas en los test.</p></li></ul></div></aside></section>
<section id="_buenas_prácticas_22"><h2>Buenas Prácticas 2/2</h2><div class="ulist"><ul><li><p>Evitar hacer test de métodos privados. Se debe probar las interfaces no las implementaciones.</p></li><li><p>Antes de pasar, los test deben fallar.</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Si se requiere probar un método privado se recomienda, extraer a una clase o en última instancia cambiar a package-private.</p></li></ul></div></aside></section>
<section id="_los_test_nos_hacen_lentos"><h2>¿Los test nos hacen lentos?</h2><div class="ulist"><ul><li><p>Los test nos ayudan a conseguir fallos. Por lo tanto, se introducen menos fallos.</p></li><li><p>Nos permite agregar cambios con confianza. Mejora la productividad.</p></li></ul></div></section>
<section id="_otros_tipos_de_tests"><h2>Otros tipos de tests</h2><div class="ulist"><ul><li><p>Behavior-driven development</p></li><li><p>Property tests</p></li><li><p>Mutation testing</p></li><li><p>Design by Contract</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Behavior-driven development: Usa un lenguaje específico del dominio para escribir los tests. Están estructurados en features e historias.</p></li><li><p>Property tests: Maneja multiples entradas para validar el comportamiento de las salidas sin necesidad de fijarlas en el código.</p></li><li><p>Mutation testing: Cambia el código fuente de los test para ver si fallan. Valida el acoplamiento entre los test y el código fuente.
Ofrece un mejor indicador que la cobertura.</p></li><li><p>Design by Contract: Valida aserciones pre y post ejecución de los métodos. Se hace control en runtime. Se puede validar en tiempo de compilación usando anotaciones.</p></li></ul></div></aside></section>
<section id="_ok_suena_genial_pero_cómo_pruebo_mis_dependencias"><h2>Ok. Suena genial ¿Pero cómo pruebo mis dependencias?</h2></section>
<section id="_testing_doubles"><h2>Testing doubles</h2><div class="ulist"><ul><li><p>Dependencias como objetos específicos de los test.</p></li><li><p>Dependencias simples llevan a menos errores.</p></li><li><p>Facilidad para controlar su comportamiento.</p></li><li><p>Facilidad para verificar su uso en los test.</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Inicializar dependencias puede llevar mucho trabajo y pueden agregar errores.</p></li><li><p>Pueden existir fallas en las dependencias.</p></li><li><p>Operaciones de I/O van a ralentizar los tests.</p></li><li><p>Usar las clases concretas de las dependencias van acoplar nuestros tests a la implementación.</p></li></ul></div></aside></section>
<section id="_tipos_de_test_doubles"><h2>Tipos de test doubles</h2><div class="ulist"><ul><li><p>Dummies</p></li><li><p>Stubs</p></li><li><p>Spikes</p></li><li><p>Fakes</p></li><li><p>Spies</p></li><li><p>Mocks</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p><strong>Dummy</strong>: Son objetos que se envían, pero nunca se utilizan en el test.
Usualmente se usan para llenar parámetros.</p></li><li><p><strong>Stub</strong>: Es un objeto en el que configuras que cuando llames a un método devuelva un valor determinado.
Usualmente se usan para cosas que no importan al test.</p></li><li><p><strong>Fake</strong>: Es un objeto que implementado completamente y que funciona, como un objeto normal sin ser simulado,
pero se diferencia en que está falseando algo para hacer alguna cosa más fácil de probar.
Un ejemplo de esto podría ser un objeto que utiliza una base de datos en memoria en lugar de acceder
a consultar la base de datos de producción.</p></li><li><p><strong>Spy</strong>: Estos objetos guardan las acciones que se hacen sobre ellos. Hace una especie de seguimiento
sobre qué métodos se han llamado y con qué parámetros.</p></li><li><p><strong>Mock</strong>: Muy similar a un spy, pero no solo guardan las acciones que se hacen sobre ellos, también es
necesario configurar qué comportamiento esperas cuando alguien llame a alguno de sus métodos.</p></li></ul></div></aside></section>
<section id="_cuál_test_double_debo_usar_12"><h2>¿Cuál test double debo usar? 1/2</h2><div class="ulist"><ul><li><p>Se recomienda seguir el PoLP (Principio de menor privilegio)</p></li><li><p>Buscar la opción menos poderosa que pueda resolver el problema.</p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Beneficios de usar PoLP:
* Declarativo
* Seguro
* Menos elementos
* Resistencia al cambio</p></div></aside></section>
<section id="_cuál_test_double_debo_usar_22"><h2>¿Cuál test double debo usar? 2/2</h2><div class="ulist"><ul><li><p>Siguiendo el principio sería:</p><div class="ulist"><ul><li><p>¿No necesitamos usar test doubles? Entonces no los usemos</p></li><li><p>¿Me sirve un stub? Entonces uso un stub</p></li><li><p>¿Necesito más control? Vamos por un fake</p></li><li><p>¿Quiero controlar todo? Usemos mocks</p></li></ul></div></li></ul></div></section>
<section id="_tdd"><h2>TDD</h2><div class="paragraph"><p><strong>Test driven development</strong></p></div>
<div class="paragraph"><p>Proceso de escribir test antes de código de producción</p></div></section>
<section id="_red_green_refactor_cycle"><h2>Red-Green-Refactor cycle</h2><div class="imageblock" style=""><img src="./images/tdd-cycle.jpg" alt="tdd cycle"></div></section>
<section id="_red_green_refactor_steps"><h2>Red-Green-Refactor steps</h2><div class="olist arabic"><ol class="arabic"><li><p>Agregar un test (Entiendo el propósito de la funcionalidad)</p></li><li><p>Ejecutar todos los test y ver si el nuevo test <span class="red">falla</span> (Debería fallar por las razones conocidas)</p></li><li><p>Escribir el mínimo código para que <span class="green">pase</span> el test</p></li><li><p>Ejecutar nuevamente el test (Valida el punto anterior)</p></li><li><p><span class="blue">Refactorizar</span> el código (Se optimiza) <strong>…​Repetir el proceso</strong></p></li></ol></div></section>
<section id="_beneficios_tdd"><h2>Beneficios TDD</h2><div class="ulist"><ul><li><p>Código con pruebas. No se pueden agregar nuevas funcionalidades sin test.</p></li><li><p>Ciclo de desarrollo rápido y seguro.</p></li><li><p>Confianza en el código y los tests.</p></li></ul></div></section>
<section id="_algunas_librerías_java_para_test"><h2>Algunas Librerías Java para test</h2><div class="ulist"><ul><li><p><a href="{https://junit.org/junit5/}">JUnit</a></p></li><li><p><a href="{https://site.mockito.org/}">Mockito</a></p></li><li><p><a href="{http://joel-costigliola.github.io/assertj/}">AssertJ</a></p></li><li><p><a href="{https://cucumber.io/}">Cucumber</a></p></li></ul></div></section>
<section id="_algunas_librerías_php_para_test"><h2>Algunas Librerías PHP para test</h2><div class="ulist"><ul><li><p><a href="{https://phpunit.de/}">PHPUnit</a></p></li></ul></div></section>
<section id="_algunas_librerías_js_para_test"><h2>Algunas Librerías JS para test</h2><div class="ulist"><ul><li><p><a href="{https://mochajs.org/}">MochaJS</a></p></li><li><p><a href="{https://jestjs.io/}">Jest</a></p></li></ul></div></section>
<section id="_phpunit"><h2>PHPUnit</h2></section>
<section id="_dependencias"><h2>Dependencias</h2><pre class="highlight listingblock"><code data-noescape class="json language-json">{
    "autoload": {
        "classmap": [
            "src/"
        ]
    },
    "require-dev": {
        "phpunit/phpunit": "^9"
    }
}</code></pre></section>
<section id="_ejemplo_validando_un_email"><h2>Ejemplo: Validando un Email</h2><pre class="highlight listingblock"><code data-noescape class="php language-php">&lt;?php declare(strict_types=1);
final class Email
{
    private $email;

    private function __construct(string $email)
    {
        $this-&gt;ensureIsValidEmail($email);

        $this-&gt;email = $email;
    }

    public static function fromString(string $email): self
    {
        return new self($email);
    }

    public function __toString(): string
    {
        return $this-&gt;email;
    }

    private function ensureIsValidEmail(string $email): void
    {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new InvalidArgumentException(
                sprintf(
                    '"%s" is not a valid email address',
                    $email
                )
            );
        }
    }
}</code></pre></section>
<section id="_test_con_phpunit"><h2>Test con PHPUnit</h2><pre class="highlight listingblock"><code data-noescape class="php language-php">&lt;?php declare(strict_types=1);
use PHPUnit\Framework\TestCase;

final class EmailTest extends TestCase
{
    public function testCanBeCreatedFromValidEmailAddress(): void
    {
        $this-&gt;assertInstanceOf(
            Email::class,
            Email::fromString('user@example.com')
        );
    }

    public function testCannotBeCreatedFromInvalidEmailAddress(): void
    {
        $this-&gt;expectException(InvalidArgumentException::class);

        Email::fromString('invalid');
    }

    public function testCanBeUsedAsString(): void
    {
        $this-&gt;assertEquals(
            'user@example.com',
            Email::fromString('user@example.com')
        );
    }
}</code></pre></section>
<section id="_phpunit_test_doubles_stubs"><h2>PHPUnit test doubles - Stubs</h2><pre class="highlight listingblock"><code data-noescape class="php language-php">public function testStub(): void
{
    // Create a stub for the SomeClass class.
    $stub = $this-&gt;createStub(SomeClass::class);

    // Configure the stub.
    $stub-&gt;method('doSomething')
        -&gt;willReturn('foo');

    // Calling $stub-&gt;doSomething() will now return
    // 'foo'.
    $this-&gt;assertSame('foo', $stub-&gt;doSomething());
}</code></pre></section>
<section id="_phpunit_test_doubles_mocks"><h2>PHPUnit test doubles - Mocks</h2><pre class="highlight listingblock"><code data-noescape class="php language-php">public function testObserversAreUpdated(): void
{
    $observer = $this-&gt;createMock(Observer::class); <i class="conum" data-value="1"></i><b>(1)</b>
    $observer-&gt;expects($this-&gt;once())
        -&gt;method('update')
        -&gt;with($this-&gt;equalTo('something')); <i class="conum" data-value="2"></i><b>(2)</b>
    $subject = new Subject('My subject');
    $subject-&gt;attach($observer);
    $subject-&gt;doSomething();
}</code></pre></section>
<section id="_cobertura_con_phpunit"><h2>Cobertura con PHPUnit</h2><div class="ulist"><ul><li><p>Requiere coverage driver: <a href="https://xdebug.org/">Xdebug</a> o <a href="https://github.com/krakjoe/pcov">PCOV</a>.</p></li><li><p>Soporta múltiples formatos</p></li></ul></div>
<pre class="highlight listingblock"><code data-noescape>  --coverage-php &lt;file&gt;       Export PHP_CodeCoverage object to file
[source,bash]</code></pre></section>
<section id="_ejemplo_6"><h2>Ejemplo</h2><pre class="highlight listingblock"><code data-noescape class="bash language-bash"> /usr/bin/php /home/juan/Dev/blog/vendor/phpunit/phpunit/phpunit --configuration /home/juan/Dev/blog/phpunit.xml --coverage-html out</code></pre></section>
<section id="_reporte" data-background-image="./images/coverage.png" data-background-size="auto"><h2>Reporte</h2></section>
<section id="_arquitectura_clean"><h2>Arquitectura Clean</h2></section>
<section id="_qué_es_arquitectura_de_software"><h2>¿Qué es arquitectura de software?</h2><div class="ulist"><ul><li><p>Estructura de un Sistema compuesta de elementos [1] con propiedades visibles de forma externa y las relaciones que existen entre ellos. <strong>Software Engineering Institute,SEI</strong>.</p></li></ul></div>
<div class="paragraph"><p>[1] Definición abstracta: objetos, hilos, clases, componentes&#8230;&#8203;</p></div></section>
<section id="_qué_no_es_una_arquitectura_de_software"><h2>¿Qué NO es una Arquitectura de Software?</h2><div class="ulist"><ul><li><p>Jerarquía de carpetas. Ej: paquetes en java.</p></li><li><p>MVC o MVP. El uso del patrón MVC o MVP no implica una arquitectura.</p></li><li><p>Estructura de un framework. Ej: Symfony, Angular, Android SDK, etc.</p></li></ul></div></section>
<section id="_introducción_a_la_arquitectura_clean"><h2>Introducción a la Arquitectura Clean</h2><div class="paragraph"><p>"Architecture is about intent, not Frameworks"</p></div>
<div class="paragraph"><p><strong>Robert C. Martin</strong></p></div></section>
<section id="_architecture_is_about_intent_not_frameworks"><h2>Architecture is about intent, not Frameworks</h2><div class="ulist"><ul><li><p>Una arquitectura se centra en lo que hace la aplicación, no en el framework o librerías que usa.</p></li><li><p>El dominio o modelo de negocio (casos de uso y entidades) debe ser el núcleo la aplicación.</p></li><li><p>Base de datos, Servicios Web, Framework, librerías, User Interface, etc. no es relevante para el modelo de negocio.</p></li></ul></div></section>
<section id="_capas_y_dependencias"><h2>Capas y Dependencias</h2></section>
<section id="_dominio_o_modelo_de_negocio" data-background-image="./images/dominio.png" data-background-size="auto"><h2>Dominio o Modelo de Negocio</h2></section>
<section id="_dominio_o_modelo_de_negocio_2"><h2>Dominio o Modelo de Negocio</h2><div class="ulist"><ul><li><p>Lo más importante de la aplicación.</p></li><li><p>No depende de ninguna otra capa.</p></li><li><p>Formado por Casos de Usos (Interactors) y entidades</p></li></ul></div></section>
<section id="_presentadores_y_controladores" data-background-image="./images/presenters.png" data-background-size="auto"><h2>Presentadores y Controladores</h2></section>
<section id="_presentadores_y_controladores_2"><h2>Presentadores y Controladores</h2><div class="ulist"><ul><li><p>Comunica las interfaces externas al dominio con los casos de uso.</p></li><li><p>Adaptadores de datos según la capa.</p></li></ul></div></section>
<section id="_interfaces_externas" data-background-image="./images/interfaces-externas.png" data-background-size="auto"><h2>Interfaces externas</h2></section>
<section id="_interfaces_externas_2"><h2>Interfaces externas</h2><div class="ulist"><ul><li><p>Framework o librerías que se usan para el desarrollo de la aplicación.</p></li><li><p>Base de datos, Interfaz de Usuario, Servicios Web, etc.</p></li></ul></div></section>
<section id="_regla_de_dependencia" data-background-image="./images/regla-de-dependencia.png" data-background-size="auto"><h2>Regla de Dependencia</h2></section>
<section id="_regla_de_dependencia_2"><h2>Regla de Dependencia</h2><div class="ulist"><ul><li><p>Las dependencias a nivel de código fuente sólo pueden apuntar hacia dentro.</p></li><li><p>Una capa interna no puede usar elementos de una capa externa.</p></li></ul></div></section>
<section id="_por_qué_la_arquitectura_clean"><h2>¿Por qué la Arquitectura Clean?</h2><div class="ulist"><ul><li><p>Evolución constante de la aplicación con nuevas funcionalidades.</p></li><li><p>Desarrollo paralelo con los servicios web.</p></li><li><p>Requisitos: minimizar al máximo las incidencias. Desarrollar test.</p></li><li><p>Posibilidad de incluir desarrolladores que no conozcan los frameworks (Android, Angular&#8230;&#8203;)</p></li></ul></div></section>
<section id="_conclusiones_solid"><h2>Conclusiones SOLID</h2><div class="ulist"><ul><li><p>SRP implica que sólo debería haber un motivo por el que modificar una clase.</p></li><li><p>Tener código cerrado a modificación y abierto a extensión nos da la máxima flexibilidad con el mínimo impacto.</p></li><li><p>El principio de Liskov nos ayuda a utilizar la herencia de forma correcta</p></li></ul></div></section>
<section id="_conclusiones_solid_2"><h2>Conclusiones SOLID</h2><div class="ulist"><ul><li><p>El principio de segregación de interfaces nos ayuda a no obligar a ninguna clase a implementar métodos que no utiliza.</p></li></ul></div></section>
<section id="_conclusiones_testing"><h2>Conclusiones Testing</h2><div class="ulist"><ul><li><p>El uso de test agrega calidad a los sistemas</p></li><li><p>Permiten hacer refactor con confianza</p></li><li><p>Deben ser independientes a nivel de datos</p></li><li><p>Mejora el diseño</p></li><li><p>Existen variedad de estrategias y herramientas para implementarlos</p></li></ul></div></section>
<section id="_conclusiones_arquitectura_clean"><h2>Conclusiones Arquitectura clean</h2><div class="ulist"><ul><li><p>La definición de la arquitectura, integración con librerías, inyección de dependencias, etc. hace que el inicio sea lento.</p></li><li><p>Al estar las funcionalidades distribuidas por capas, se crea la sensación de no encontrar el código o de estar perdido.</p></li><li><p>El trabajar con capas te aísla de problemas que afectan a otras capas.</p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Recomendación: crear un proyecto con todo esto definido y que sea la base de futuros proyectos.</p></div></aside></section>
<section id="_conclusiones_arquitectura_clean_2"><h2>Conclusiones Arquitectura Clean</h2><div class="ulist"><ul><li><p>El trabajar con abstracciones permite que el proyecto sea más flexible ante cambios.</p></li><li><p>Reutilización de código. Toda la lógica está centrada en la capa de dominio que es accesible desde cualquier otra capa.</p></li><li><p>Código testeable. No hay código acoplado que no permita falsear ciertos datos para comprobar distintos comportamientos.</p></li></ul></div></section>
<section><div class="ulist"><ul><li><p>Fuentes:</p><div class="ulist"><ul><li><p><a href="https://webcourse.cs.technion.ac.il/236700/Spring2018/ho.html">236700 - Software Design, Spring2018 - Course Material</a></p></li><li><p><a href="https://refactoring.com">Refactoring</a></p></li><li><p><a href="https://www.javiergarzas.com/2015/09/dummies-vs-stubs-vs-mocks-vs-spies-vs-fakes.html">Javier Garzas - Dependencias en pruebas unitarias</a></p></li><li><p><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Robert C. Martin - The Clean Architecture</a></p></li><li><p><a href="https://devexperto.com/principio-responsabilidad-unica/">Pricipios SOLID - DevExperto</a></p></li></ul></div></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Para generar pdf incluir al final de la presentación lo siguiente: ?showNotes=separate-page&amp;print-pdf</p></div></aside></section></div></div><script src="reveal.js/lib/js/head.min.js"></script><script src="reveal.js/js/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
})

// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display presentation control arrows
  controls: false,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: 'true',
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Push each slide change to the browser history
  history: true,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'linear',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
      { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
      { src: 'reveal.js/plugin/notes/notes.js', async: true },
      
      
      
      
  ],

  

});</script></body></html>